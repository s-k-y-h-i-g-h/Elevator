@using Elevator.Shared.Services.Interfaces
@using Elevator.Shared.Services.DTOs
@using Radzen
@using Radzen.Blazor
@inject IDiscussionService DiscussionService
@inject IAuthenticationService AuthService
@inject NotificationService NotificationService

<RadzenStack Orientation="Orientation.Horizontal" AlignItems="AlignItems.Center" Gap="0.5rem">
    @if (AuthService.IsAuthenticated)
    {
        <RadzenButton Icon="keyboard_arrow_up" 
                    ButtonStyle="@(userVote?.IsUpvote == true ? ButtonStyle.Success : ButtonStyle.Light)" 
                    Size="ButtonSize.Small" 
                    Click="@(() => HandleVote(true))"
                    IsBusy="@isVoting" />
    }
    else
    {
        <RadzenButton Icon="keyboard_arrow_up" 
                    ButtonStyle="ButtonStyle.Light" 
                    Size="ButtonSize.Small" 
                    Disabled="true" />
    }
    
    <RadzenText TextStyle="TextStyle.Body2" Style="min-width: 30px; text-align: center; font-weight: 600;">
        @GetVoteScore()
    </RadzenText>
    
    @if (AuthService.IsAuthenticated)
    {
        <RadzenButton Icon="keyboard_arrow_down" 
                    ButtonStyle="@(userVote?.IsUpvote == false ? ButtonStyle.Danger : ButtonStyle.Light)" 
                    Size="ButtonSize.Small" 
                    Click="@(() => HandleVote(false))"
                    IsBusy="@isVoting" />
    }
    else
    {
        <RadzenButton Icon="keyboard_arrow_down" 
                    ButtonStyle="ButtonStyle.Light" 
                    Size="ButtonSize.Small" 
                    Disabled="true" />
    }
</RadzenStack>

@code {
    [Parameter] public int? DiscussionId { get; set; }
    [Parameter] public int? CommentId { get; set; }
    [Parameter] public int UpvoteCount { get; set; }
    [Parameter] public int DownvoteCount { get; set; }
    [Parameter] public EventCallback OnVoteChanged { get; set; }
    
    private VoteDto? userVote;
    private bool isVoting = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadUserVote();
    }

    private async Task LoadUserVote()
    {
        if (!AuthService.IsAuthenticated) return;

        try
        {
            // Note: This would require a method to get user's vote for a specific discussion/comment
            // For now, we'll assume no existing vote
            userVote = null;
        }
        catch (Exception ex)
        {
            // Handle error silently
            userVote = null;
        }
    }

    private async Task HandleVote(bool isUpvote)
    {
        if (!AuthService.IsAuthenticated) return;

        isVoting = true;
        StateHasChanged();

        try
        {
            // If user already voted the same way, remove the vote
            if (userVote != null && userVote.IsUpvote == isUpvote)
            {
                // This would require a delete vote method
                userVote = null;
            }
            else
            {
                var createVoteDto = new CreateVoteDto
                {
                    DiscussionId = DiscussionId,
                    CommentId = CommentId,
                    IsUpvote = isUpvote,
                    UserId = AuthService.CurrentUserId
                };

                var newVote = await DiscussionService.VoteAsync(createVoteDto);
                userVote = newVote;
            }

            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Success,
                Summary = "Vote Recorded",
                Detail = $"Your {(isUpvote ? "upvote" : "downvote")} has been recorded.",
                Duration = 2000
            });

            await OnVoteChanged.InvokeAsync();
        }
        catch (Exception ex)
        {
            NotificationService.Notify(new NotificationMessage
            {
                Severity = NotificationSeverity.Error,
                Summary = "Vote Failed",
                Detail = "Failed to record your vote. Please try again.",
                Duration = 4000
            });
        }
        finally
        {
            isVoting = false;
            StateHasChanged();
        }
    }

    private int GetVoteScore()
    {
        return UpvoteCount - DownvoteCount;
    }
}